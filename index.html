<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Angel Vazquez - Software Engineer</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <style>
        /* Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            overflow: hidden;
            font-family: Arial, sans-serif;
            touch-action: manipulation;
        }
        
        /* Interactive Game Elements */
        .pyramid-svg {
            position: absolute;
            z-index: 1;
        }
        
        .game-info {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 1000;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
        
        /* Touch zones for mobile */
        .touch-zones {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }
        
        .touch-zone {
            position: absolute;
            pointer-events: auto;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .touch-zone:active {
            opacity: 0.1;
            background: white;
        }
        
        .touch-top {
            top: 0;
            left: 25%;
            width: 50%;
            height: 50%;
            z-index: 12;
        }
        
        .touch-bottom {
            bottom: 0;
            left: 25%;
            width: 50%;
            height: 50%;
            z-index: 12;
        }
        
        .touch-left {
            top: 25%;
            left: 0;
            width: 50%;
            height: 50%;
            z-index: 11;
        }
        
        .touch-right {
            top: 25%;
            right: 0;
            width: 50%;
            height: 50%;
            z-index: 11;
        }
        
        /* Show touch zones on mobile */
        @media (max-width: 768px) {
            .touch-zones {
                display: block;
            }
            
            .game-info {
                font-size: 10px;
                padding: 8px;
            }
        }
        
        /* Portfolio Text Display */
        .portfolio-text {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            color: white;
            text-align: center;
            z-index: 1001;
            pointer-events: none;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
            /* Responsive scaling */
            font-size: clamp(0.5rem, 2vw, 1rem);
            width: 90vw;
            max-width: 600px;
        }
        
        .name {
            font-size: clamp(2rem, 8vw, 3rem);
            font-weight: 300;
            margin: 0 0 0.5rem 0;
            opacity: 0;
            animation: neonReveal 2s ease-in-out 1s forwards;
        }
        
        .title {
            font-size: clamp(1rem, 4.5vw, 1.65rem);
            font-weight: 300;
            margin: 0 0 1.5rem 0;
            opacity: 0;
            animation: neonReveal 2s ease-in-out 2s forwards;
            letter-spacing: 0.1em;
        }
        
        .neon-line {
            width: clamp(120px, 20vw, 200px);
            height: 2px;
            background: white;
            margin: 0 auto 1.25rem auto;
            opacity: 0;
            animation: neonReveal 2s ease-in-out 2.5s forwards;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
        }
        
        .social-links {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            opacity: 0;
            animation: neonReveal 2s ease-in-out 3s forwards;
        }
        
        .social-row-top {
            display: flex;
            gap: clamp(2rem, 8vw, 3.75rem);
            justify-content: center;
        }
        
        .social-row-bottom {
            display: flex;
            justify-content: center;
        }
        
        .social-links a {
            display: inline-block;
            transition: all 0.3s ease;
            filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.5));
            pointer-events: auto;
        }
        
        .social-links a:hover {
            transform: translateY(-3px);
            filter: drop-shadow(0 0 20px rgba(255, 255, 255, 0.8));
        }
        
        .social-links svg {
            width: clamp(20px, 5vw, 30px);
            height: clamp(20px, 5vw, 30px);
            fill: white;
            stroke: white;
        }
        
        /* Animations */
        @keyframes neonReveal {
            0% { 
                opacity: 0; 
                text-shadow: 0 0 5px rgba(255, 255, 255, 0.3); 
            }
            50% { 
                opacity: 0.7; 
                text-shadow: 0 0 30px rgba(255, 255, 255, 0.9); 
            }
            100% { 
                opacity: 1; 
                text-shadow: 0 0 20px rgba(255, 255, 255, 0.8); 
            }
        }
    </style>
</head>
<body>
    <!-- Game Interface -->
    <div class="game-info" id="game-info">
        The Wireframe Pyramids are Interactive, Enjoy!<br>
        Pyramids: <span id="pyramid-count">0</span><br>
        Speed: <span id="speed-display">1.0</span>x<br>
        <span id="controls-text">↑ ↓ arrows: + / - pyramids<br>
        ←  → arrows: + / -  speed</span>
    </div>
    
    <!-- Touch zones for mobile -->
    <div class="touch-zones">
        <div class="touch-zone touch-top" data-action="pyramid-up"></div>
        <div class="touch-zone touch-bottom" data-action="pyramid-down"></div>
        <div class="touch-zone touch-left" data-action="speed-down"></div>
        <div class="touch-zone touch-right" data-action="speed-up"></div>
    </div>

    <!-- Portfolio Content -->
    <div class="portfolio-text">
        <h1 class="name">ANGEL VAZQUEZ</h1>
        <h2 class="title">SOFTWARE ENGINEER</h2>
        <div class="neon-line"></div>
        <div class="social-links">
            <div class="social-row-top">
                <a href="https://github.com/AngelCodes95" target="_blank" aria-label="GitHub Profile">
                    <svg viewBox="0 0 24 24">
                        <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                    </svg>
                </a>
                <a href="https://linkedin.com/in/angelthedev" target="_blank" aria-label="LinkedIn Profile">
                    <svg viewBox="0 0 24 24">
                        <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
                    </svg>
                </a>
            </div>
            <div class="social-row-bottom">
                <a href="https://angelcodes95.github.io/angel-portfolio-docs" target="_blank" aria-label="Portfolio Documentation">
                    <svg viewBox="0 0 24 24">
                        <path d="M21 5c-1.11-.35-2.33-.5-3.5-.5-1.95 0-4.05.4-5.5 1.5-1.45-1.1-3.55-1.5-5.5-1.5S2.45 4.9 1 6v14.65c0 .25.25.5.5.5.1 0 .15-.05.25-.05C3.1 20.45 5.05 20 6.5 20c1.95 0 4.05.4 5.5 1.5 1.35-.85 3.8-1.5 5.5-1.5 1.65 0 3.35.3 4.75 1.05.1.05.15.05.25.05.25 0 .5-.25.5-.5V6c-.6-.45-1.25-.75-2-1zm0 13.5c-1.1-.35-2.3-.5-3.5-.5-1.7 0-4.15.65-5.5 1.5V8c1.35-.85 3.8-1.5 5.5-1.5 1.2 0 2.4.15 3.5.5v11.5z"/>
                    </svg>
                </a>
            </div>
        </div>
    </div>

    <script>
        /**
         * PORTFOLIO SITE WITH INTERACTIVE 3D WIREFRAME PYRAMIDS
         * 
         * This application combines a portfolio presentation with an interactive
         * 3D pyramid game. Features:
         * - 3D wireframe pyramids that bounce around the screen
         * - Matrix-style animated text presentation
         * - Keyboard controls for pyramid count and speed
         * - Falling pyramid rain effect in background
         * - Responsive design with dynamic sizing
         */


        // UTILITY FUNCTIONS
        /**
         * Generate random integer between min and max (inclusive)
         */
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        /**
         * Get random color from predefined palette
         */
        function getRandomColor() {
            const colorPalette = [
                '#ffffff', '#ff6b35', '#f7931e', '#ffd100', 
                '#90ee02', '#00d4aa', '#0099cc', '#951b81'
            ];
            return colorPalette[getRandomInt(0, colorPalette.length - 1)];
        }

        /**
         * Calculate responsive pyramid size based on viewport dimensions
         * Size scales with screen size but stays within reasonable bounds
         */
        function calculatePyramidSize() {
            const minViewportDimension = Math.min(window.innerWidth, window.innerHeight);
            const responsiveSize = minViewportDimension * 0.06; // 6% of smaller dimension
            return Math.max(25, Math.min(80, responsiveSize)); // Clamp between 25px and 80px
        }


        // 3D MATHEMATICS AND PROJECTION FUNCTIONS
        /**
         * Project 3D coordinates to 2D screen coordinates using orthographic projection
         * No perspective distortion - maintains consistent size regardless of depth
         */
        function project3D(x, y, z, canvasSize) {
            const centerOffset = canvasSize / 2;
            return {
                x: x + centerOffset,
                y: y + centerOffset
            };
        }

        /**
         * Rotate point around Y-axis (horizontal spinning)
         */
        function rotateAroundY(x, y, z, angleRadians) {
            const cosAngle = Math.cos(angleRadians);
            const sinAngle = Math.sin(angleRadians);
            return {
                x: x * cosAngle + z * sinAngle,
                y: y,
                z: -x * sinAngle + z * cosAngle
            };
        }

        /**
         * Rotate point around X-axis (vertical tilting)
         */
        function rotateAroundX(x, y, z, angleRadians) {
            const cosAngle = Math.cos(angleRadians);
            const sinAngle = Math.sin(angleRadians);
            return {
                x: x,
                y: y * cosAngle - z * sinAngle,
                z: y * sinAngle + z * cosAngle
            };
        }

        // MAIN BOUNCING PYRAMID CLASS
        /**
         * Interactive 3D wireframe pyramid that bounces around the screen
         * Features collision detection, color changes on bounce, and 3D rotation
         */
        class BouncingPyramid {
            constructor(pyramidId) {
                this.id = pyramidId;
                this.size = calculatePyramidSize();
                
                this.calculateDimensions();
                this.createSVGElement();
                this.setRandomInitialState();
                this.render();
            }

            /**
             * Calculate pyramid dimensions and collision bounds
             * Accounts for 3D rotation requiring extra space
             */
            calculateDimensions() {
                const baseSize = this.size * 0.7;
                const apexHeight = this.size * 0.8;
                
                // When rotating, diagonal becomes the required width/height
                const maxRotationDimension = Math.sqrt(baseSize * baseSize + baseSize * baseSize) + apexHeight;
                this.canvasSize = Math.ceil(maxRotationDimension * 1.2); // 20% padding for safe rotation
                
                this.collisionBounds = {
                    width: this.canvasSize,
                    height: this.canvasSize
                };
                
                // Define 3D pyramid geometry
                this.baseVertices = [
                    { x: -baseSize, y: this.size/2, z: -baseSize }, // front-left
                    { x: baseSize, y: this.size/2, z: -baseSize },  // front-right
                    { x: baseSize, y: this.size/2, z: baseSize },   // back-right
                    { x: -baseSize, y: this.size/2, z: baseSize }   // back-left
                ];
                this.apexVertex = { x: 0, y: -this.size * 0.8, z: 0 };
            }

            /**
             * Create and configure SVG element for pyramid rendering
             */
            createSVGElement() {
                this.svgElement = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                this.svgElement.setAttribute('class', 'pyramid-svg');
                this.svgElement.setAttribute('viewBox', `0 0 ${this.canvasSize} ${this.canvasSize}`);
                this.svgElement.style.width = this.canvasSize + 'px';
                this.svgElement.style.height = this.canvasSize + 'px';
                document.body.appendChild(this.svgElement);
            }

            /**
             * Set random starting position, velocity, and rotation
             */
            setRandomInitialState() {
                // Position within screen bounds
                this.x = getRandomInt(0, window.innerWidth - this.collisionBounds.width);
                this.y = getRandomInt(0, window.innerHeight - this.collisionBounds.height);
                
                // Velocity (relatively slow for smooth movement)
                this.velocityX = getRandomInt(1, 2) * (Math.random() > 0.5 ? 1 : -1);
                this.velocityY = getRandomInt(1, 2) * (Math.random() > 0.5 ? 1 : -1);
                
                // 3D rotation state
                this.rotationY = 0;
                this.rotationX = 0;
                this.rotationSpeedY = 0.005 + Math.random() * 0.02;
                this.rotationSpeedX = (0.005 + Math.random() * 0.02) * 0.5; // Slower X rotation
                
                this.color = getRandomColor();
                this.updatePosition();
            }

            /**
             * Update pyramid size when window is resized
             * Ensures pyramids stay within bounds after resize
             */
            handleResize() {
                this.size = calculatePyramidSize();
                this.calculateDimensions();
                this.svgElement.setAttribute('viewBox', `0 0 ${this.canvasSize} ${this.canvasSize}`);
                this.svgElement.style.width = this.canvasSize + 'px';
                this.svgElement.style.height = this.canvasSize + 'px';
                
                // Keep within new screen bounds
                if (this.x + this.collisionBounds.width > window.innerWidth) {
                    this.x = window.innerWidth - this.collisionBounds.width;
                }
                if (this.y + this.collisionBounds.height > window.innerHeight) {
                    this.y = window.innerHeight - this.collisionBounds.height;
                }
                this.updatePosition();
            }

            /**
             * Render the 3D wireframe pyramid with current rotation
             */
            render() {
                this.svgElement.innerHTML = '';
                
                // Apply 3D rotations to all vertices
                const rotatedBase = this.baseVertices.map(vertex => {
                    let rotated = rotateAroundY(vertex.x, vertex.y, vertex.z, this.rotationY);
                    return rotateAroundX(rotated.x, rotated.y, rotated.z, this.rotationX);
                });
                
                let rotatedApex = rotateAroundY(this.apexVertex.x, this.apexVertex.y, this.apexVertex.z, this.rotationY);
                rotatedApex = rotateAroundX(rotatedApex.x, rotatedApex.y, rotatedApex.z, this.rotationX);
                
                // Project 3D points to 2D screen coordinates
                const projectedBase = rotatedBase.map(vertex => 
                    project3D(vertex.x, vertex.y, vertex.z, this.canvasSize)
                );
                const projectedApex = project3D(rotatedApex.x, rotatedApex.y, rotatedApex.z, this.canvasSize);
                
                // Define wireframe edges
                const wireframeEdges = [
                    // Square base edges
                    [projectedBase[0], projectedBase[1]],
                    [projectedBase[1], projectedBase[2]],
                    [projectedBase[2], projectedBase[3]],
                    [projectedBase[3], projectedBase[0]],
                    // Apex to base edges
                    [projectedApex, projectedBase[0]],
                    [projectedApex, projectedBase[1]],
                    [projectedApex, projectedBase[2]],
                    [projectedApex, projectedBase[3]]
                ];
                
                // Draw wireframe lines
                wireframeEdges.forEach(([startPoint, endPoint]) => {
                    const lineElement = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    lineElement.setAttribute('x1', startPoint.x);
                    lineElement.setAttribute('y1', startPoint.y);
                    lineElement.setAttribute('x2', endPoint.x);
                    lineElement.setAttribute('y2', endPoint.y);
                    lineElement.setAttribute('stroke', this.color);
                    lineElement.setAttribute('stroke-width', '1.5');
                    lineElement.setAttribute('fill', 'none');
                    this.svgElement.appendChild(lineElement);
                });
            }

            /**
             * Change pyramid color (called on wall collision)
             */
            changeColor() {
                this.color = getRandomColor();
            }

            /**
             * Update SVG element position on screen
             */
            updatePosition() {
                this.svgElement.style.left = this.x + 'px';
                this.svgElement.style.top = this.y + 'px';
            }

            /**
             * Main update loop: movement, collision detection, rotation, rendering
             */
            update() {
                // Calculate next position
                let nextX = this.x + this.velocityX;
                let nextY = this.y + this.velocityY;
                
                // Wall collision detection and response
                if (nextX <= 0) {
                    nextX = 0;
                    this.velocityX = Math.abs(this.velocityX);
                    this.changeColor();
                } else if (nextX + this.collisionBounds.width >= window.innerWidth) {
                    nextX = window.innerWidth - this.collisionBounds.width;
                    this.velocityX = -Math.abs(this.velocityX);
                    this.changeColor();
                }
                
                if (nextY <= 0) {
                    nextY = 0;
                    this.velocityY = Math.abs(this.velocityY);
                    this.changeColor();
                } else if (nextY + this.collisionBounds.height >= window.innerHeight) {
                    nextY = window.innerHeight - this.collisionBounds.height;
                    this.velocityY = -Math.abs(this.velocityY);
                    this.changeColor();
                }
                
                // Update position and rotation
                this.x = nextX;
                this.y = nextY;
                this.updatePosition();
                
                this.rotationY += this.rotationSpeedY;
                this.rotationX += this.rotationSpeedX;
                
                this.render();
            }

            /**
             * Remove pyramid from DOM
             */
            destroy() {
                this.svgElement.remove();
            }
        }

        // FALLING PYRAMID RAIN EFFECT
        /**
         * Small 3D pyramid that falls from top of screen
         * Creates matrix-like rain effect behind the main content
         */
        class FallingPyramid {
            constructor(startX) {
                this.x = startX;
                this.y = -50; // Start above screen
                this.fallSpeed = Math.random() * 1 + 0.5; // Smooth falling speed
                this.size = 15;
                this.rotationY = 0;
                this.rotationX = 0;
                this.rotationSpeedY = 0.01 + Math.random() * 0.02; // Gentle rotation
                this.rotationSpeedX = (0.01 + Math.random() * 0.02) * 0.5;
                this.opacity = 0.7;
                
                this.createSVGElement();
                this.definePyramidGeometry();
                this.render();
            }

            /**
             * Create SVG element for falling pyramid
             */
            createSVGElement() {
                this.svgElement = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                this.svgElement.setAttribute('viewBox', '0 0 30 30');
                this.svgElement.style.position = 'absolute';
                this.svgElement.style.width = '30px';
                this.svgElement.style.height = '30px';
                this.svgElement.style.left = this.x + 'px';
                this.svgElement.style.top = this.y + 'px';
                this.svgElement.style.pointerEvents = 'none';
                this.svgElement.style.opacity = this.opacity;
                document.body.appendChild(this.svgElement);
            }

            /**
             * Define small pyramid 3D geometry
             */
            definePyramidGeometry() {
                const baseSize = this.size * 0.7;
                this.baseVertices = [
                    { x: -baseSize, y: this.size/2, z: -baseSize },
                    { x: baseSize, y: this.size/2, z: -baseSize },
                    { x: baseSize, y: this.size/2, z: baseSize },
                    { x: -baseSize, y: this.size/2, z: baseSize }
                ];
                this.apexVertex = { x: 0, y: -this.size * 0.8, z: 0 };
            }

            /**
             * Render falling pyramid with 3D rotation
             */
            render() {
                this.svgElement.innerHTML = '';
                
                // Apply rotations
                const rotatedBase = this.baseVertices.map(vertex => {
                    let rotated = rotateAroundY(vertex.x, vertex.y, vertex.z, this.rotationY);
                    return rotateAroundX(rotated.x, rotated.y, rotated.z, this.rotationX);
                });
                
                let rotatedApex = rotateAroundY(this.apexVertex.x, this.apexVertex.y, this.apexVertex.z, this.rotationY);
                rotatedApex = rotateAroundX(rotatedApex.x, rotatedApex.y, rotatedApex.z, this.rotationX);
                
                // Project to 2D (centered at 15,15)
                const projectedBase = rotatedBase.map(vertex => ({
                    x: vertex.x + 15,
                    y: vertex.y + 15
                }));
                const projectedApex = {
                    x: rotatedApex.x + 15,
                    y: rotatedApex.y + 15
                };
                
                // Draw wireframe
                const wireframeEdges = [
                    [projectedBase[0], projectedBase[1]],
                    [projectedBase[1], projectedBase[2]],
                    [projectedBase[2], projectedBase[3]],
                    [projectedBase[3], projectedBase[0]],
                    [projectedApex, projectedBase[0]],
                    [projectedApex, projectedBase[1]],
                    [projectedApex, projectedBase[2]],
                    [projectedApex, projectedBase[3]]
                ];
                
                wireframeEdges.forEach(([startPoint, endPoint]) => {
                    const lineElement = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    lineElement.setAttribute('x1', startPoint.x);
                    lineElement.setAttribute('y1', startPoint.y);
                    lineElement.setAttribute('x2', endPoint.x);
                    lineElement.setAttribute('y2', endPoint.y);
                    lineElement.setAttribute('stroke', 'white');
                    lineElement.setAttribute('stroke-width', '1');
                    lineElement.setAttribute('fill', 'none');
                    this.svgElement.appendChild(lineElement);
                });
            }

            /**
             * Update falling pyramid position and rotation
             * Returns false when pyramid should be removed
             */
            update() {
                this.y += this.fallSpeed;
                this.svgElement.style.top = this.y + 'px';
                
                this.rotationY += this.rotationSpeedY;
                this.rotationX += this.rotationSpeedX;
                
                // Gradual fade out
                this.opacity -= 0.001;
                this.svgElement.style.opacity = this.opacity;
                
                this.render();
                
                // Remove when off screen or faded
                if (this.y > window.innerHeight + 50 || this.opacity <= 0) {
                    this.svgElement.remove();
                    return false; // Signal for removal from array
                }
                return true; // Continue existing
            }
        }

        // GAME STATE AND MANAGEMENT
        const gameState = {
            pyramids: [],
            fallingPyramids: [],
            initialPyramidCount: 3,
            maxPyramids: 111,
            currentSpeedMultiplier: 1.0,
            fallingPyramidInterval: 800 // milliseconds
        };

        // Initialize bouncing pyramids
        for (let i = 0; i < gameState.initialPyramidCount; i++) {
            gameState.pyramids.push(new BouncingPyramid(i));
        }

        // Update UI display
        document.getElementById('pyramid-count').textContent = gameState.initialPyramidCount;

        // ANIMATION AND UPDATE LOOPS
        /**
         * Main animation loop
         * Updates all bouncing pyramids and falling pyramid rain
         */
        function mainAnimationLoop() {
            // Update bouncing pyramids
            gameState.pyramids.forEach(pyramid => pyramid.update());
            
            // Update falling pyramids (remove finished ones)
            for (let i = gameState.fallingPyramids.length - 1; i >= 0; i--) {
                if (!gameState.fallingPyramids[i].update()) {
                    gameState.fallingPyramids.splice(i, 1);
                }
            }
            
            requestAnimationFrame(mainAnimationLoop);
        }

        /**
         * Create new falling pyramid at random horizontal position
         */
        function createFallingPyramid() {
            const randomX = Math.random() * (window.innerWidth - 30);
            const fallingPyramid = new FallingPyramid(randomX);
            gameState.fallingPyramids.push(fallingPyramid);
        }

        // EVENT HANDLERS
        /**
         * Handle window resize - update all pyramid sizes
         */
        window.addEventListener('resize', () => {
            gameState.pyramids.forEach(pyramid => pyramid.handleResize());
        });

        /**
         * Keyboard controls for pyramid count and speed
         */
        window.addEventListener('keydown', (event) => {
            switch (event.key) {
                case 'ArrowUp':
                    if (gameState.pyramids.length < gameState.maxPyramids) {
                        const newPyramid = new BouncingPyramid(gameState.pyramids.length);
                        gameState.pyramids.push(newPyramid);
                        document.getElementById('pyramid-count').textContent = gameState.pyramids.length;
                    }
                    break;
                    
                case 'ArrowDown':
                    if (gameState.pyramids.length > 0) {
                        const removedPyramid = gameState.pyramids.pop();
                        removedPyramid.destroy();
                        document.getElementById('pyramid-count').textContent = gameState.pyramids.length;
                    }
                    break;
                    
                case 'ArrowRight':
                    if (gameState.currentSpeedMultiplier < 9.0) {
                        gameState.currentSpeedMultiplier *= 1.1;
                        gameState.pyramids.forEach(pyramid => {
                            pyramid.velocityX *= 1.1;
                            pyramid.velocityY *= 1.1;
                            pyramid.rotationSpeedY *= 1.1;
                            pyramid.rotationSpeedX *= 1.1;
                        });
                        document.getElementById('speed-display').textContent = gameState.currentSpeedMultiplier.toFixed(1);
                    }
                    break;
                    
                case 'ArrowLeft':
                    if (gameState.currentSpeedMultiplier > 0.1) {
                        gameState.currentSpeedMultiplier *= 0.9;
                        gameState.pyramids.forEach(pyramid => {
                            pyramid.velocityX *= 0.9;
                            pyramid.velocityY *= 0.9;
                            pyramid.rotationSpeedY *= 0.9;
                            pyramid.rotationSpeedX *= 0.9;
                        });
                        document.getElementById('speed-display').textContent = gameState.currentSpeedMultiplier.toFixed(1);
                    }
                    break;
            }
        });

        // MOBILE TOUCH CONTROLS
        /**
         * Detect if device is mobile and update controls display
         */
        function isMobileDevice() {
            return window.innerWidth <= 768 || 'ontouchstart' in window;
        }

        /**
         * Update controls text based on device type
         */
        function updateControlsDisplay() {
            const controlsText = document.getElementById('controls-text');
            if (isMobileDevice()) {
                controlsText.innerHTML = 'Tap/Hold top/bottom: + / - pyramids<br>Tap/Hold left/right: + / - speed';
            } else {
                controlsText.innerHTML = '↑ ↓ arrows: + / - pyramids<br>←  → arrows: + / -  speed';
            }
        }

        /**
         * Handle touch zone interactions with hold-to-repeat functionality
         */
        function setupTouchControls() {
            const touchZones = document.querySelectorAll('.touch-zone');
            let holdInterval = null;
            let holdTimeout = null;
            
            touchZones.forEach(zone => {
                const executeAction = (action) => {
                    switch (action) {
                        case 'pyramid-up':
                            if (gameState.pyramids.length < gameState.maxPyramids) {
                                const newPyramid = new BouncingPyramid(gameState.pyramids.length);
                                gameState.pyramids.push(newPyramid);
                                document.getElementById('pyramid-count').textContent = gameState.pyramids.length;
                            }
                            break;
                            
                        case 'pyramid-down':
                            if (gameState.pyramids.length > 0) {
                                const removedPyramid = gameState.pyramids.pop();
                                removedPyramid.destroy();
                                document.getElementById('pyramid-count').textContent = gameState.pyramids.length;
                            }
                            break;
                            
                        case 'speed-up':
                            if (gameState.currentSpeedMultiplier < 9.0) {
                                gameState.currentSpeedMultiplier *= 1.1;
                                gameState.pyramids.forEach(pyramid => {
                                    pyramid.velocityX *= 1.1;
                                    pyramid.velocityY *= 1.1;
                                    pyramid.rotationSpeedY *= 1.1;
                                    pyramid.rotationSpeedX *= 1.1;
                                });
                                document.getElementById('speed-display').textContent = gameState.currentSpeedMultiplier.toFixed(1);
                            }
                            break;
                            
                        case 'speed-down':
                            if (gameState.currentSpeedMultiplier > 0.1) {
                                gameState.currentSpeedMultiplier *= 0.9;
                                gameState.pyramids.forEach(pyramid => {
                                    pyramid.velocityX *= 0.9;
                                    pyramid.velocityY *= 0.9;
                                    pyramid.rotationSpeedY *= 0.9;
                                    pyramid.rotationSpeedX *= 0.9;
                                });
                                document.getElementById('speed-display').textContent = gameState.currentSpeedMultiplier.toFixed(1);
                            }
                            break;
                    }
                };
                
                zone.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const action = zone.dataset.action;
                    
                    // Execute action immediately
                    executeAction(action);
                    
                    // Set up hold-to-repeat after 500ms
                    holdTimeout = setTimeout(() => {
                        holdInterval = setInterval(() => {
                            executeAction(action);
                        }, 100); // Repeat every 100ms while holding
                    }, 500); // Start repeating after 500ms hold
                });
                
                // Stop hold-to-repeat on touch end
                zone.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    if (holdTimeout) {
                        clearTimeout(holdTimeout);
                        holdTimeout = null;
                    }
                    if (holdInterval) {
                        clearInterval(holdInterval);
                        holdInterval = null;
                    }
                });
                
                // Stop hold-to-repeat if touch is cancelled
                zone.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    if (holdTimeout) {
                        clearTimeout(holdTimeout);
                        holdTimeout = null;
                    }
                    if (holdInterval) {
                        clearInterval(holdInterval);
                        holdInterval = null;
                    }
                });
            });
        }

        // Handle window resize - update controls and pyramid sizes
        window.addEventListener('resize', () => {
            gameState.pyramids.forEach(pyramid => pyramid.handleResize());
            updateControlsDisplay();
        });

        // APPLICATION INITIALIZATION
        // Setup controls based on device
        updateControlsDisplay();
        setupTouchControls();
        
        // Start main animation loop
        mainAnimationLoop();

        // Start falling pyramid rain effect
        setInterval(createFallingPyramid, gameState.fallingPyramidInterval);
    </script>
</body>
</html>